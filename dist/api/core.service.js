/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/* tslint:disable:no-unused-variable member-ordering */
import { Inject, Injectable, Optional } from '@angular/core';
import { FlexiCoreDecycle } from './flexiCoreDecycle';
import { map } from 'rxjs/operators';
import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration';
import { HttpHeaders, HttpRequest } from '@angular/common/http';
let CoreService = class CoreService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     *
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    extendObj(objA, objB) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * @param roleId
     * @param userId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    addUserToRole(roleId, userId, authenticationkey, extraHttpRequestParams) {
        return this.addUserToRoleWithHttpInfo(roleId, userId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param crtId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    attachCertificate(id, crtId, authenticationkey, extraHttpRequestParams) {
        return this.attachCertificateWithHttpInfo(id, crtId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    attachTenant(authenticationkey, body, extraHttpRequestParams) {
        return this.attachTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     */
    checkDBAvailable(extraHttpRequestParams) {
        return this.checkDBAvailableWithHttpInfo(extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Connect a Category to an instance of any entity in the system
     * @summary Connect to Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    connectCategory(baseId, authenticationkey, catId, extraHttpRequestParams) {
        return this.connectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    connectToTenant(authenticationkey, body, extraHttpRequestParams) {
        return this.connectToTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param type
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    count(type, authenticationkey, body, extraHttpRequestParams) {
        return this.countWithHttpInfo(type, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    countAllofType(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        return this.countAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    countConnected(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        return this.countConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    countDisconnected(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        return this.countDisconnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Creates a link between two instances in a generic way, provide values of the link
     * @summary Create a link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    createBaselink(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams) {
        return this.createBaselinkWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Return a single category
     * @summary Create a Category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    createCategory(categoryName, authenticationkey, extraHttpRequestParams) {
        return this.createCategoryWithHttpInfo(categoryName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    createRole(authenticationkey, body, extraHttpRequestParams) {
        return this.createRoleWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param tenantName
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    createTenant(tenantName, apiKey, authenticationkey, body, extraHttpRequestParams) {
        return this.createTenantWithHttpInfo(tenantName, apiKey, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param tenantName
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    createTenantNoUser(tenantName, apiKey, authenticationkey, extraHttpRequestParams) {
        return this.createTenantNoUserWithHttpInfo(tenantName, apiKey, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess
     * @param body
     */
    createUser(authenticationkey, loginuponsuccess, body, extraHttpRequestParams) {
        return this.createUserWithHttpInfo(authenticationkey, loginuponsuccess, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteById(id, authenticationkey, extraHttpRequestParams) {
        return this.deleteByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteById_2(id, className, authenticationkey, extraHttpRequestParams) {
        return this.deleteById_2WithHttpInfo(id, className, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteFileResource(md5, authenticationkey, extraHttpRequestParams) {
        return this.deleteFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * delete heap dump
     * @summary deleteHeapDump
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteHeapDump(id, authenticationkey, extraHttpRequestParams) {
        return this.deleteHeapDumpWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteMedia(id, authenticationkey, extraHttpRequestParams) {
        return this.deleteMediaWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Remove an existing link by the ID of its 'sides'
     * @summary Remove a link
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    detachEntities(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams) {
        return this.detachEntitiesWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Disable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39;
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    disableCategory(className, authenticationkey, body, extraHttpRequestParams) {
        return this.disableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @summary Disconnect from Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    disconnectCategory(baseId, authenticationkey, catId, extraHttpRequestParams) {
        return this.disconnectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    download(authenticationkey, id, extraHttpRequestParams) {
        return this.downloadWithHttpInfo(authenticationkey, id, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @summary duplicate an entity, shallow by id
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    duplicate(id, authenticationkey, extraHttpRequestParams) {
        return this.duplicateWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Enable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39;
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    enableCategory(className, authenticationkey, body, extraHttpRequestParams) {
        return this.enableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * exports to file
     * @summary export baseclass
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    exportBaseclass(id, authenticationkey, extraHttpRequestParams) {
        return this.exportBaseclassWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    fileResourcesOfType(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        return this.fileResourcesOfTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * finalize FileResource , sending it for processing
     * @summary finalize
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint
     * @param fileType
     * @param dontProcess
     */
    finalizeUpload(md5, authenticationkey, hint, fileType, dontProcess, extraHttpRequestParams) {
        return this.finalizeUploadWithHttpInfo(md5, authenticationkey, hint, fileType, dontProcess, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Find an entity by Id and type, returns null if not found
     * @summary find entity by id and class
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findById(id, classname, authenticationkey, extraHttpRequestParams) {
        return this.findByIdWithHttpInfo(id, classname, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @summary Find an instance by ID
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findById_3(ID, authenticationkey, extraHttpRequestParams) {
        return this.findById_3WithHttpInfo(ID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findById_4(id, authenticationkey, extraHttpRequestParams) {
        return this.findById_4WithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findByName(name, classname, authenticationkey, extraHttpRequestParams) {
        return this.findByNameWithHttpInfo(name, classname, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     */
    findBySidesId(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams) {
        return this.findBySidesIdWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinks(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.findLinksWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinksContainers(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.findLinksContainersWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinksValues(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.findLinksValuesWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param clientType
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view
     */
    generateClient(clientType, authenticationkey, view, extraHttpRequestParams) {
        return this.generateClientWithHttpInfo(clientType, authenticationkey, view, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getAllCategories(authenticationkey, pagesize, currentpage, extraHttpRequestParams) {
        return this.getAllCategoriesWithHttpInfo(authenticationkey, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Get a list of all Categories that are connected to an instance
     * @summary List Categories  by Instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllCategoriesConnected(baseId, authenticationkey, extraHttpRequestParams) {
        return this.getAllCategoriesConnectedWithHttpInfo(baseId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllFileTypes(authenticationkey, extraHttpRequestParams) {
        return this.getAllFileTypesWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @summary Get all Operations
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllOperations(clazzName, authenticationkey, extraHttpRequestParams) {
        return this.getAllOperationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @summary Get a list of all associations
     * @param clazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAssociations(clazzName, authenticationkey, extraHttpRequestParams) {
        return this.getAssociationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @summary List Categories  by Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getCategory(className, authenticationkey, extraHttpRequestParams) {
        return this.getCategoryWithHttpInfo(className, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getCategoryByName(name, authenticationkey, extraHttpRequestParams) {
        return this.getCategoryByNameWithHttpInfo(name, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @summary Get a Clazz instance from a canonical name
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getClazz(clazzName, authenticationkey, extraHttpRequestParams) {
        return this.getClazzWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getClients(authenticationkey, extraHttpRequestParams) {
        return this.getClientsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getConnected(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        return this.getConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param wantedClazzName
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getDisconnected(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        return this.getDisconnectedWithHttpInfo(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    getFeatures(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        return this.getFeaturesWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getFileResource(md5, authenticationkey, extraHttpRequestParams) {
        return this.getFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param jobID
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getJob(jobID, authenticationkey, extraHttpRequestParams) {
        return this.getJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view
     */
    getSwaggerJSON(authenticationkey, view, extraHttpRequestParams) {
        return this.getSwaggerJSONWithHttpInfo(authenticationkey, view, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getTenant(apiKey, authenticationkey, extraHttpRequestParams) {
        return this.getTenantWithHttpInfo(apiKey, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getTenants(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.getTenantsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * import baseclass
     * @summary import baseclass
     * @param className
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    importBaseclass(className, authenticationkey, body, extraHttpRequestParams) {
        return this.importBaseclassWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    invalidateCache(authenticationkey, extraHttpRequestParams) {
        return this.invalidateCacheWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param leftId
     * @param rightId
     * @param operationId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    linkBaseclassTouser(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams) {
        return this.linkBaseclassTouserWithHttpInfo(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @summary Link Role and User
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    linkroleuser(authenticationkey, body, extraHttpRequestParams) {
        return this.linkroleuserWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listAllLoadedPlugins(authenticationkey, extraHttpRequestParams) {
        return this.listAllLoadedPluginsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    listAllRoles(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.listAllRolesWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listAllUserRoles(id, authenticationkey, extraHttpRequestParams) {
        return this.listAllUserRolesWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    listAllUsers(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        return this.listAllUsersWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * lists license requests
     * @summary
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    listLicenseRequest(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        return this.listLicenseRequestWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param email
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    lookupUserByEmail(email, authenticationkey, extraHttpRequestParams) {
        return this.lookupUserByEmailWithHttpInfo(email, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    lookupUserById(id, authenticationkey, extraHttpRequestParams) {
        return this.lookupUserByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number
     */
    multipleCreate(authenticationkey, number, extraHttpRequestParams) {
        return this.multipleCreateWithHttpInfo(authenticationkey, number, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name with wildcard
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    nameLike(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        return this.nameLikeWithHttpInfo(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     */
    ping(extraHttpRequestParams) {
        return this.pingWithHttpInfo(extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * registers components if not exists and returns allowed
     * @summary registerAndGetAllowedUIComponents
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    registerAndGetAllowedUIComponents(authenticationkey, body, extraHttpRequestParams) {
        return this.registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path
     * @param calcMd5
     */
    registerFile(authenticationkey, path, calcMd5, extraHttpRequestParams) {
        return this.registerFileWithHttpInfo(authenticationkey, path, calcMd5, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path
     * @param hint
     * @param fileType
     * @param dontProcess
     * @param calcMd5
     */
    registerFileAndFinlize(authenticationkey, path, hint, fileType, dontProcess, calcMd5, extraHttpRequestParams) {
        return this.registerFileAndFinlizeWithHttpInfo(authenticationkey, path, hint, fileType, dontProcess, calcMd5, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    restart(authenticationkey, extraHttpRequestParams) {
        return this.restartWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * soft delete baseclass
     * @summary softDelete
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    softDelete(id, authenticationkey, extraHttpRequestParams) {
        return this.softDeleteWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param jobID
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    stopJob(jobID, authenticationkey, extraHttpRequestParams) {
        return this.stopJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    testUpdate(authenticationkey, extraHttpRequestParams) {
        return this.testUpdateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     * Update an instance of a Baseclass using a BasicContainer instance
     * @summary Update basic data
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    updateBasicDetails(authenticationkey, body, extraHttpRequestParams) {
        return this.updateBasicDetailsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param jobID
     * @param phaseName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    updateJobPhase(jobID, phaseName, authenticationkey, extraHttpRequestParams) {
        return this.updateJobPhaseWithHttpInfo(jobID, phaseName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param jobID
     * @param key
     * @param value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    updateJobProperty(jobID, key, value, authenticationkey, extraHttpRequestParams) {
        return this.updateJobPropertyWithHttpInfo(jobID, key, value, authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    validate(authenticationkey, extraHttpRequestParams) {
        return this.validateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response) => {
            if (response.status === 204) {
                return undefined;
            }
            else {
                return FlexiCoreDecycle.retrocycle(response.json()) || {};
            }
        }));
    }
    /**
     *
     *
     * @param roleId
     * @param userId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    addUserToRoleWithHttpInfo(roleId, userId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/users/addToRole/${roleId}/${userId}'
            .replace('${' + 'roleId' + '}', String(roleId))
            .replace('${' + 'userId' + '}', String(userId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling addUserToRole.');
        }
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addUserToRole.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param crtId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    attachCertificateWithHttpInfo(id, crtId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/license/attachCertificate/${id}/${crtId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'crtId' + '}', String(crtId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling attachCertificate.');
        }
        // verify required parameter 'crtId' is not null or undefined
        if (crtId === null || crtId === undefined) {
            throw new Error('Required parameter crtId was null or undefined when calling attachCertificate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * attach file resource
     * attachs a file resource to the given media , using primary bundle
     * @param mediaId
     * @param fileResourceId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group
     */
    attachFileResourceWithHttpInfo(mediaId, fileResourceId, authenticationkey, group, extraHttpRequestParams) {
        const path = this.basePath + '/media/attachFileResource/${media_id}/${fileResource_id}'
            .replace('${' + 'media_id' + '}', String(mediaId))
            .replace('${' + 'fileResource_id' + '}', String(fileResourceId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling attachFileResource.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling attachFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    attachTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/users/attachTennat';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param fileResourceId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    changeMediaPrimaryFileResourceBundleWithHttpInfo(id, fileResourceId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/media/${id}/${fileResourceId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     */
    checkDBAvailableWithHttpInfo(extraHttpRequestParams) {
        const path = this.basePath + '/ping/checkDBAvailable';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Connect to Category
     * Connect a Category to an instance of any entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    connectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams) {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * connectDeviceToBaseclass
     * Connect a Device to an instance of any entity in the system
     * @param baseId
     * @param mac
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param someHeader
     */
    connectDeviceToBaseclassWithHttpInfo(baseId, mac, authenticationkey, someHeader, extraHttpRequestParams) {
        const path = this.basePath + '/device/connectDeviceToBaseclass/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectDeviceToBaseclass.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling connectDeviceToBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (someHeader !== undefined && someHeader !== null) {
            headers.set('someHeader', String(someHeader));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * connect Property
     * Connect a property and a baseclass with a complex type, this is the actual action of assigning a Complex Value of a property to a specific Baseclass , any Baseclasss
     * @param propertyId the ID of the Property instance to use
     * @param baseclassId The ID of the Baseclass to which we want to assign this complex value
     * @param valueId The ID of the ? extends Baseclass which is the complex value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    connectPropertyComplexWithHttpInfo(propertyId, baseclassId, valueId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/property/connectComplex/${propertyId}/${baseclass_id}/${value_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId))
            .replace('${' + 'value_id' + '}', String(valueId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'valueId' is not null or undefined
        if (valueId === null || valueId === undefined) {
            throw new Error('Required parameter valueId was null or undefined when calling connectPropertyComplex.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * connect Property
     * Connect property and a baseclass with simple value, assign a value of a Property to an instance of Baseclass, any Baseclass instance
     * @param propertyId The ID of the property, this Property must be connected eith the Clazz of the Baseclass in the baseclass_id parameter
     * @param baseclassId The Baseclass instance to which this value (for that property) is set
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to set, must be a String
     */
    connectPropertySimpleWithHttpInfo(propertyId, baseclassId, authenticationkey, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/property/connectSimple/${propertyId}/${baseclass_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertySimple.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertySimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    connectToTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/users/connectToTenant';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param type
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    countWithHttpInfo(type, authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/count/${type}'
            .replace('${' + 'type' + '}', String(type));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling count.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    countAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/media/count';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    countConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/countConnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    countDisconnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/countDisconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Create a link
     * Creates a link between two instances in a generic way, provide values of the link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    createBaselinkWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling createBaselink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        if (check !== undefined && check !== null) {
            headers.set('check', String(check));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Create a Category
     * Return a single category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    createCategoryWithHttpInfo(categoryName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/category';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'categoryName' is not null or undefined
        if (categoryName === null || categoryName === undefined) {
            throw new Error('Required parameter categoryName was null or undefined when calling createCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (categoryName !== undefined && categoryName !== null) {
            headers.set('categoryName', String(categoryName));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * createDevice
     * creates a device
     * @param mac
     * @param serialNumber
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param name
     * @param lat
     * @param lon
     */
    createDeviceWithHttpInfo(mac, serialNumber, authenticationkey, name, lat, lon, extraHttpRequestParams) {
        const path = this.basePath + '/device/createDevice/${mac}/${serialNumber}'
            .replace('${' + 'mac' + '}', String(mac))
            .replace('${' + 'serialNumber' + '}', String(serialNumber));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling createDevice.');
        }
        // verify required parameter 'serialNumber' is not null or undefined
        if (serialNumber === null || serialNumber === undefined) {
            throw new Error('Required parameter serialNumber was null or undefined when calling createDevice.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }
        if (lat !== undefined && lat !== null) {
            headers.set('lat', String(lat));
        }
        if (lon !== undefined && lon !== null) {
            headers.set('lon', String(lon));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * createHeapDump
     * create heap dump
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path
     */
    createHeapDumpWithHttpInfo(authenticationkey, pathparam, extraHttpRequestParams) {
        const path = this.basePath + '/debug/createHeapDump';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * creates Property
     * creates a property given a type and a name, properties can be created and linked with Types. instances of these types can have associated values
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyName
     * @param propertyType
     */
    createPropertyWithHttpInfo(authenticationkey, propertyName, propertyType, extraHttpRequestParams) {
        const path = this.basePath + '/property';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (propertyName !== undefined && propertyName !== null) {
            headers.set('propertyName', String(propertyName));
        }
        if (propertyType !== undefined && propertyType !== null) {
            headers.set('propertyType', String(propertyType));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * creates Property Type
     * creates a property Type given  a name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyTypeName  the name of the property type to create
     */
    createPropertyTypeWithHttpInfo(authenticationkey, propertyTypeName, extraHttpRequestParams) {
        const path = this.basePath + '/property/createType';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (propertyTypeName !== undefined && propertyTypeName !== null) {
            headers.set('propertyTypeName', String(propertyTypeName));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    createRoleWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/roles';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param tenantName
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    createTenantWithHttpInfo(tenantName, apiKey, authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/tenant/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenant.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param tenantName
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    createTenantNoUserWithHttpInfo(tenantName, apiKey, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/tenant/createTenantNoUser/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenantNoUser.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenantNoUser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * createUIInterface
     * creates UI interface
     * @param name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    createUIInterfaceWithHttpInfo(name, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/uiPlugin/createUIInterface/${name}'
            .replace('${' + 'name' + '}', String(name));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createUIInterface.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess
     * @param body
     */
    createUserWithHttpInfo(authenticationkey, loginuponsuccess, body, extraHttpRequestParams) {
        const path = this.basePath + '/users/new';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (loginuponsuccess !== undefined && loginuponsuccess !== null) {
            headers.set('loginuponsuccess', String(loginuponsuccess));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * deactivateAllLinks
     * deactivate all links between a device and baseclass
     * @param baseId
     * @param mac
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deactivateAllLinksWithHttpInfo(baseId, mac, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/device/deactivateAllLinks/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling deactivateAllLinks.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling deactivateAllLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * deactivateLink
     * deactivate link
     * @param linkId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deactivateLinkWithHttpInfo(linkId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/device/deactivateLink/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling deactivateLink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteById_2WithHttpInfo(id, className, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/${class_name}/${id}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'class_name' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById_2.');
        }
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling deleteById_2.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling deleteFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * deleteHeapDump
     * delete heap dump
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteHeapDumpWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/debug/deleteHeapDump/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteHeapDump.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deleteMediaWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Remove a link
     * Remove an existing link by the ID of its &#39;sides&#39;
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    detachEntitiesWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling detachEntities.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * device get settings
     * create Settings
     * @param settingsId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    deviceGetSettingsWithHttpInfo(settingsId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/deviceGetSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling deviceGetSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Disable Category on Class
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39;
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    disableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/category/${class_name}/disable'
            .replace('${' + 'class_name' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling disableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Disconnect from Category
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    disconnectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams) {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling disconnectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    downloadWithHttpInfo(authenticationkey, id, extraHttpRequestParams) {
        const path = this.basePath + '/download/${authenticationkey}/${id}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey))
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling download.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling download.');
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * duplicate an entity, shallow by id
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    duplicateWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/clone/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling duplicate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Enable Category on Class
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39;
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    enableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/category/enable/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling enableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * export baseclass
     * exports to file
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    exportBaseclassWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/exportBaseclass/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * export settings
     * export Settings
     * @param settingsId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    exportSettingsWithHttpInfo(settingsId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/exportSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling exportSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    fileResourcesOfTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/media/fileResourcesOfType';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * finalize
     * finalize FileResource , sending it for processing
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint
     * @param fileType
     * @param dontProcess
     */
    finalizeUploadWithHttpInfo(md5, authenticationkey, hint, fileType, dontProcess, extraHttpRequestParams) {
        const path = this.basePath + '/resources/finalize/${md5}'
            .replace('${' + 'md5' + '}', String(md5));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling finalizeUpload.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }
        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }
        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * find entity by id and class
     * Find an entity by Id and type, returns null if not found
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findByIdWithHttpInfo(id, classname, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/getbyid/${id}/${classname}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Find an instance by ID
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findById_3WithHttpInfo(ID, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'ID' + '}', String(ID));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'ID' is not null or undefined
        if (ID === null || ID === undefined) {
            throw new Error('Required parameter ID was null or undefined when calling findById_3.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findById_4WithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/roles/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById_4.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Find an instance by its name
     * returns a list of instances of the type requested
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    findByNameWithHttpInfo(name, classname, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/${name}/${classname}'
            .replace('${' + 'Name' + '}', String(name))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling findByName.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     */
    findBySidesIdWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findBySidesId.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinksWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/findLinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinks.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinks.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinksContainersWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/findLinksContainers/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param left
     * @param right
     * @param classname
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value
     * @param simpleValue
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    findLinksValuesWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/findLinksValues/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksValues.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param clientType
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view
     */
    generateClientWithHttpInfo(clientType, authenticationkey, view, extraHttpRequestParams) {
        const path = this.basePath + '/swagger/extended/generateClient/${client_type}'
            .replace('${' + 'client_type' + '}', String(clientType));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clientType' is not null or undefined
        if (clientType === null || clientType === undefined) {
            throw new Error('Required parameter clientType was null or undefined when calling generateClient.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param targetDevice
     */
    getWithHttpInfo(id, authenticationkey, targetDevice, extraHttpRequestParams) {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (targetDevice !== undefined && targetDevice !== null) {
            headers.set('targetDevice', String(targetDevice));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getAllCategoriesWithHttpInfo(authenticationkey, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/category/getAll';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * List Categories  by Instance
     * Get a list of all Categories that are connected to an instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllCategoriesConnectedWithHttpInfo(baseId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/category/connected/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling getAllCategoriesConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllFileTypesWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/media/types';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get all Operations
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllOperationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/clazz/operations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAllOperations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     * returns a list of views
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAllViewsWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/view';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get a list of all associations
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @param clazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getAssociationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/clazz/associations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAssociations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * List Categories  by Class
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getCategoryWithHttpInfo(className, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/category/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getCategoryByNameWithHttpInfo(name, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/category/byname/${name}'
            .replace('${' + 'name' + '}', String(name));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getCategoryByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get a Clazz instance from a canonical name
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getClazzWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/clazz/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getClazz.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getClientsWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/swagger/extended/clients';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param wantedClazzName
     * @param id
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/connected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * getDeviceUsedProperties
     * update device used properties
     * @param mac
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    getDeviceUsedPropertiesWithHttpInfo(mac, authenticationkey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/device/getDeviceUsedProperties/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getDeviceUsedProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param wantedClazzName
     * @param linkClazzName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getDisconnectedWithHttpInfo(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/disconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view
     */
    getDocsWithHttpInfo(authenticationkey, view, extraHttpRequestParams) {
        const path = this.basePath + '/swagger/extended/docs/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getDocs.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * get Connected Properties
     * get all properties connected to baseclass
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz
     * @param plainView
     */
    getDynamicPropertiesWithHttpInfo(id, authenticationkey, propertyClazz, plainView, extraHttpRequestParams) {
        const path = this.basePath + '/property/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }
        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * get Connected Properties With Categories
     * get all properties connected to baseclass
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz
     * @param plainView
     */
    getDynamicPropertiesWithCategoriesWithHttpInfo(id, authenticationkey, propertyClazz, plainView, extraHttpRequestParams) {
        const path = this.basePath + '/property/getDynamicPropertiesWithCategories/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicPropertiesWithCategories.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }
        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    getFeaturesWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/license/getFeatures';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Get Field Containers per class
     * get a list of all FieldContainers per class, use it for the creation of a new instance and for updating one
     * @param clazzName The canonical name of the Class for which the list is to be obtained
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getFieldsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/clazz/fields/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getFields.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param className
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getFields_5WithHttpInfo(className, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/media/${class_name}/fields'
            .replace('${' + 'class_name' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getFields_5.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param md5
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling getFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param jobID
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling getJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view
     */
    getSwaggerJSONWithHttpInfo(authenticationkey, view, extraHttpRequestParams) {
        const path = this.basePath + '/swagger/extended/swagger.json/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getSwaggerJSON.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param apiKey
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getTenantWithHttpInfo(apiKey, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/tenant/${apiKey}'
            .replace('${' + 'apiKey' + '}', String(apiKey));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    getTenantsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/tenant';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param viewId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    getViewClazzesWithHttpInfo(viewId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/view/clazzes/${viewId}'
            .replace('${' + 'viewId' + '}', String(viewId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'viewId' is not null or undefined
        if (viewId === null || viewId === undefined) {
            throw new Error('Required parameter viewId was null or undefined when calling getViewClazzes.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * import baseclass
     * import baseclass
     * @param className
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    importBaseclassWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/importBaseclass/${className}'
            .replace('${' + 'className' + '}', String(className));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling importBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    invalidateCacheWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/swagger/extended/invalidateCache';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param leftId
     * @param rightId
     * @param operationId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    linkBaseclassTouserWithHttpInfo(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/linkUserToBaseclass/${left_id}/${right_id}/${operation_id}'
            .replace('${' + 'left_id' + '}', String(leftId))
            .replace('${' + 'right_id' + '}', String(rightId))
            .replace('${' + 'operation_id' + '}', String(operationId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'operationId' is not null or undefined
        if (operationId === null || operationId === undefined) {
            throw new Error('Required parameter operationId was null or undefined when calling linkBaseclassTouser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Link Role and User
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    linkroleuserWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/baselinks/linkroleuser';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby
     */
    listAllWithHttpInfo(authenticationkey, pagesize, currentpage, sortby, extraHttpRequestParams) {
        const path = this.basePath + '/media';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (sortby !== undefined && sortby !== null) {
            headers.set('sortby', String(sortby));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * fileResourcesInMediaByGroup
     * lists all media that suites Filtering information holder
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    listAllFileResourcesOfGroupInMediaWithHttpInfo(id, authenticationkey, group, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/media/list/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllFileResourcesOfGroupInMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * get file resources
     * returns all the file resources of the given types that are connected to the given Media
     * @param mediaId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    listAllFileResourcesOfTypeWithHttpInfo(mediaId, authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/media/fileResources/${media_id}'
            .replace('${' + 'media_id' + '}', String(mediaId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling listAllFileResourcesOfType.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listAllLoadedPluginsWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    listAllRolesWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/roles/list';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * lists all Settings
     * lists all settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    listAllSettingsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/settings/listAllSettings';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * lists all Settings Metadata
     * lists all settings metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    listAllSettingsMetadataWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/settings';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listAllUserRolesWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/roles/userRoles/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllUserRoles.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    listAllUsersWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/users';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     * lists all media that suites Filtering information holder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    listAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/media';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listDeviceSettingss
     * list device Settings
     * @param deviceId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listDeviceSettingsWithHttpInfo(deviceId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/listDeviceSettings/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listDeviceSettingsContainers
     * list device Settings containers
     * @param mac
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    listDeviceSettingsContainersWithHttpInfo(mac, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/listDeviceSettingsContainers/${mac}'
            .replace('${' + 'mac' + '}', String(mac));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling listDeviceSettingsContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listDevicesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/device/listDevices';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listHeapDumps
     * list heap dumps
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param start
     */
    listHeapDumpsWithHttpInfo(authenticationkey, body, pagesize, currentpage, start, extraHttpRequestParams) {
        const path = this.basePath + '/debug/listHeapDumps';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (start !== undefined && start !== null) {
            headers.set('start', String(start));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     * lists license requests
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    listLicenseRequestWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/license/listAll';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listProperties
     * get all Properties, paged, filtered and sorted by a FilteringInformationHolder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listPropertiesWithHttpInfo(authenticationkey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/property/listProperties';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listPropertyTypes
     * get all property types, filtered and sorted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    listPropertyTypesWithHttpInfo(authenticationkey, body, pagesize, currentPage, extraHttpRequestParams) {
        const path = this.basePath + '/property/listPropertyTypes';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * lists Settings
     * lists settings
     * @param settingsMetadataId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    listSettingsWithHttpInfo(settingsMetadataId, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/settings/listSettings/${settingsMetadataId}'
            .replace('${' + 'settingsMetadataId' + '}', String(settingsMetadataId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'settingsMetadataId' is not null or undefined
        if (settingsMetadataId === null || settingsMetadataId === undefined) {
            throw new Error('Required parameter settingsMetadataId was null or undefined when calling listSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listUIInterfaces
     * lists ui interfaces
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    listUIInterfacesWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/uiPlugin/listUIInterfaces';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * listUIPluginsByInterface
     * lists plugin by interface
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param interfaceId
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body
     */
    listUIPluginsByInterfaceWithHttpInfo(authenticationkey, interfaceId, pagesize, currentpage, body, extraHttpRequestParams) {
        const path = this.basePath + '/uiPlugin/listUIPluginsByInterface/${interfaceId}';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (interfaceId !== undefined && interfaceId !== null) {
            headers.set('interfaceId', String(interfaceId));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param email
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    lookupUserByEmailWithHttpInfo(email, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/users/byEmail/${email}'
            .replace('${' + 'email' + '}', String(email));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling lookupUserByEmail.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    lookupUserByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/users/byId/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling lookupUserById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number
     */
    multipleCreateWithHttpInfo(authenticationkey, number, extraHttpRequestParams) {
        const path = this.basePath + '/users/batchCreate';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (number !== undefined && number !== null) {
            headers.set('number', String(number));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Find an instance by its name with wildcard
     * returns a list of instances of the type requested
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    nameLikeWithHttpInfo(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/like/name/${classname}'
            .replace('${' + 'classname' + '}', String(classname));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling nameLike.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }
        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     */
    pingWithHttpInfo(extraHttpRequestParams) {
        const path = this.basePath + '/ping';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * registerAndGetAllowedUIComponents
     * registers components if not exists and returns allowed
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/uiPlugin/registerAndGetAllowedUIComponents';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path
     * @param calcMd5
     */
    registerFileWithHttpInfo(authenticationkey, pathparam, calcMd5, extraHttpRequestParams) {
        const path = this.basePath + '/resources/register';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }
        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path
     * @param hint
     * @param fileType
     * @param dontProcess
     * @param calcMd5
     */
    registerFileAndFinlizeWithHttpInfo(authenticationkey, pathparam, hint, fileType, dontProcess, calcMd5, extraHttpRequestParams) {
        const path = this.basePath + '/resources/registerAndFinalize';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(pathparam));
        }
        if (path !== undefined && path !== null) {
            headers.set('path', String(path));
        }
        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }
        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }
        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }
        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('POST', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    restartWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * setsActiveSettings
     * sets active settings for settingsMetadata
     * @param settingsMetaId
     * @param settingId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    setActiveSettingsWithHttpInfo(settingsMetaId, settingId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/setActiveSettings/${settingsMetaId}/${settingId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId))
            .replace('${' + 'settingId' + '}', String(settingId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettings.');
        }
        // verify required parameter 'settingId' is not null or undefined
        if (settingId === null || settingId === undefined) {
            throw new Error('Required parameter settingId was null or undefined when calling setActiveSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * setActiveSettingsAsDefault
     * sets active settings for settingsMetadata as null(using default values)
     * @param settingsMetaId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    setActiveSettingsAsDefaultWithHttpInfo(settingsMetaId, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/settings/setActiveSettingsAsDefault/${settingsMetaId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettingsAsDefault.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * softDelete
     * soft delete baseclass
     * @param id
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    softDeleteWithHttpInfo(id, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass/softDelete/${id}'
            .replace('${' + 'id' + '}', String(id));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling softDelete.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param jobID
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    stopJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling stopJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('DELETE', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    testUpdateWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/plugins/testUpdate';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * Update basic data
     * Update an instance of a Baseclass using a BasicContainer instance
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body
     */
    updateBasicDetailsWithHttpInfo(authenticationkey, body, extraHttpRequestParams) {
        const path = this.basePath + '/baseclass';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [];
        headers.set('Content-Type', 'application/json');
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            body: body == null ? '' : JSON.stringify(body),
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param jobID
     * @param phaseName
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    updateJobPhaseWithHttpInfo(jobID, phaseName, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/jobProcess/updateJobPhase/${jobID}/${phaseName}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'phaseName' + '}', String(phaseName));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobPhase.');
        }
        // verify required parameter 'phaseName' is not null or undefined
        if (phaseName === null || phaseName === undefined) {
            throw new Error('Required parameter phaseName was null or undefined when calling updateJobPhase.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param jobID
     * @param key
     * @param value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    updateJobPropertyWithHttpInfo(jobID, key, value, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/jobProcess/updateJobProperty/${jobID}/${key}/${value}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'key' + '}', String(key))
            .replace('${' + 'value' + '}', String(value));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling updateJobProperty.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * update metadata property
     * update metadata property
     * @param linkId
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue
     */
    updateMetadataSimpleWithHttpInfo(linkId, authenticationkey, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/settings/updateMetadataSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateMetadataSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     * updateSimple
     * update Simple value of a Dynamic Property of a Baseclass instance
     * @param linkId The link id (of PropertyToBaseclass type)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to update
     */
    updateSimpleWithHttpInfo(linkId, authenticationkey, simpleValue, extraHttpRequestParams) {
        const path = this.basePath + '/property/updateSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param id
     * @param updateTo
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    updateVersionWithHttpInfo(id, updateTo, authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/media/updateVersion/${id}/${updateTo}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'updateTo' + '}', String(updateTo));
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVersion.');
        }
        // verify required parameter 'updateTo' is not null or undefined
        if (updateTo === null || updateTo === undefined) {
            throw new Error('Required parameter updateTo was null or undefined when calling updateVersion.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('PUT', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
    /**
     *
     *
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    validateWithHttpInfo(authenticationkey, extraHttpRequestParams) {
        const path = this.basePath + '/resources/validate';
        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }
        // to determine the Accept header
        let produces = [
            'application/json'
        ];
        let requestOptions = new HttpRequest('GET', path, {
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = Object.assign(requestOptions, extraHttpRequestParams);
        }
        return this.httpClient.request(requestOptions).pipe(map(o => FlexiCoreDecycle.retrocycle(o)));
    }
};
CoreService = __decorate([
    Injectable(),
    __param(1, Optional()),
    __param(1, Inject(BASE_PATH)),
    __param(2, Optional())
], CoreService);
export { CoreService };
//# sourceMappingURL=core.service.js.map